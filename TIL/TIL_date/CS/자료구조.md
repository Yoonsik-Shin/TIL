# 자료구조

​    

## Array

### 1. Array

- 연관된 데이터를 __메모리상에 연속적__이며 __순차적__으로 __미리 할당된 크기만큼__ 저장하는 자료구조
- 조회와 append가 빨라 조회를 자주 해야하는 작업에서 많이 사용됨 (장점)
- 선언시에 Array의 크기를 미리 정해야하여, 메모리 낭비나 추가적인 overhead가 발생할 수 있음 (단점)

| 동작                        | 시간복잡도 |
| --------------------------- | ---------- |
| 조회                        | O(1)       |
| 마지막 인덱스 추가 (append) | O(1)       |
| 마지막 인덱스 삭제 (pop)    | O(1)       |
| 삽입 삭제, 탐색             | O(n)       |

![image-20230626221719003](자료구조.assets/image-20230626221719003.png)

​    

> random access

- 배열의 연속된 구조를 이용하여 배열의 첫번째 메모리 위치와 데이터 크기를 이용하여 조회하는 방법

```c
// 3의 주소값 = 첫번째 주소값 + (4byte(숫자) * (3-1)번째 인덱스) 
    04xAF5D   =   0x4AF55    + (     4      *        2       )byte
```



> 미리 예상한 것보다 더 많은 데이터를 저장하게되어 Array의 사이즈를 넘게 되었을때 어떻게 해결해야할까?

- 기존 Array 사이즈보다 더 큰 Array를 선언하고 기본 데이터를 새 Array에 옮겨 할당합니다.
- 그 후, 모든 데이터를 옮겼다면 기본 Array는 메모리에서 삭제됩니다.
- 이러한 방식으로 동적으로 배열의 크기를 조절하는 자료구조를 `Dynamic array`라고 함
- 사이즈 예측이 어렵다면 Array대신 Linked list를 사용해 데이터가 추가될 때마다 메모리 공간을 할당받는 방식을 사용하는 것을 추천함

​    

### 2. Dynamic Array

- 사이즈를 자동적으로 재조정한는 Array로 기존 고정된 사이즈를 가진 Static Array의 한계점을 보완하고자 고안되었습니다.
- 데이터를 계속 추가하다가 기존에 할당된 메모리를 초과하게되면, 사이즈를 늘린 배열을 선언하고 그곳으로 모든 데이터를 옮겨담아 새로운 사이즈를 가진 배열이 됩니다.
- 사이즈를 미리 고민하지 않아도 되는 장점이 있습니다.
- 사이즈 재조정의 대표적인 방법에는 기존 배열의 사이즈의 2배를 할당하는 doubling이 있습니다.

​    

> Doubling

- 데이터를 추가하다가 메모리를 초과하게되면 기존 배열의 사이즈보다 두 배 더 큰 배열을 선언하고 데이터를 일일히 옮기는 방법으로
- n개의 데이터를 일일히 옮겨야하므로 O(n)의 시간복잡도를 가집니다.

<img src="자료구조.assets/image-20230626223905887.png" alt="image-20230626223905887" style="zoom:50%;" />

> 분할 상환 시간복잡도 (Amortized time complexity)

- 가끔 발생하는 O(n)의 resize 시간을 자주 발생하는 O(1)의 작업들이 분담해 나눠가져 전체적으로는 O(1)의 시간이 걸린다고 말하며 이를 amortized O(1)이라고 부릅니다.

​        

### 3. Linked List

- Node라는 구조체로 이루어져 있습니다.
- 이 때, Node는 데이터 값과 다음 Node의 주소값을 저장하고 있습니다.
- 물리적 메모리상에서는 비연속적으로 저장되지만, 각각의 Node가 다음 Node의 주소값을 가리키고 있어 논리적으로는 연속성을 가진다고 말하는 자료구조입니다.

![image-20230626224451189](자료구조.assets/image-20230626224451189.png)

<img src="자료구조.assets/image-20230626224459738.png" alt="image-20230626224459738" style="zoom:50%;" />

- 물리적으로 옮길 필요가 없이 next address가 가리키는 주소값만 변경하면돼 삽입/삭제에 O(1)의 시간복잡도를 가집니다.

![image-20230626224605783](자료구조.assets/image-20230626224605783.png)

​    

### 4. 꼬리질문

> Array와 Linked List를 비교하여 설명

- Array는 물리적 메모리상에 연속적으로 데이터를 저장하는 자료구조이고, Linked List는 물리적 메모리상에서 연속적이지 않지만, 각각의 Node가 다음 Node의 메모리 주소값을 저장해놓아 논리적으로 연속성을 유지하는 자료구조입니다.
- 데이터 조회시 Array는 random access(즉시접근)를 통해 O(1)의 시간복잡도를 가지고 Linked List는 sequential access(순차접근)을 하여 O(n)의 시간복잡도를 가집니다.
- 데이터 삽입과 삭제시에는 Array는 O(n)의 시간복잡도를 가집니다. Linked List는 O(1)의 시간복잡도를 가지는데 특정 인덱스에 접근하려면 O(n)의 시간이 걸리므로 실질적으로는 O(n)의 시간복잡도를 가집니다.
- 만약 얼마만큼 데이터를 저장할지 미리 알고, 조회를 많이 한다면 Array를 사용하는 것이 좋고, 몇개의 데이터를 저장할지 불확실하고 삽입, 삭제가 잦으면 Linked List를 사용하는 것이 더 좋습니다.

​    

> 어느 상황에서 Linked List가 Array보다 나을까?

- 데이터 삽입/삭제가 잦을때
- 얼마만큼 데이터가 들어올지 예측할 수 없을 때
- 조회가 많지 않을 때

​    

> 어느 상황에서 Array가 Linked List보다 나은가?

- 조회작업이 잦을 때
- Array 선언 당시에 데이터 개수를 알고 있을 때
- 반복문을 통해 빠르게 순회할 때
- 메모리를 적게 쓰는게 중요할 때
- 미리 들어올 데이터의 양을 알고 있을 때

​    

> Array와 Linked List의 memory allocation은 언제 일어나며, 메모리의 어느 영역에 할당받는지?

- Array는 compile 단계에서 메모리할당이 일어납니다.
- 이를 Static memory allocation이라고 하고, Stack 메모리 영역에 할당됩니다.
- Linked List는 runtime 단계에서 새로운 Node가 추가될 때 마다 메모리할당이 일어납니다.
- 이를 Dynamic memory allocation이라고 하고, Heap 메모리 영역에 할당됩니다.

## 



